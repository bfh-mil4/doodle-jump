<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Doodle Jump - HTML5 Game</title>
  <style>
    html, body {
      height: 100%;
      margin: 0;
      display: flex;
      justify-content: center;
      align-items: center;
      background-color: #f0f0f0;
    }
    canvas {
      border: 2px solid black;
      background-color: lightblue;
    }
  </style>
</head>
<body>

<canvas id="gameCanvas" width="375" height="667"></canvas>

<script>
// Setup the game canvas and context
const canvas = document.getElementById('gameCanvas');
const context = canvas.getContext('2d');

// Define platform properties
const platformWidth = 65;
const platformHeight = 20;
const initialPlatformY = canvas.height - 50;

// Game physics
const gravity = 0.4;
const bounceVelocity = -10;
const horizontalSpeed = 3;
const maxPlatformGap = 150;

// Platforms array to store platform coordinates
let platforms = [{ x: canvas.width / 2 - platformWidth / 2, y: initialPlatformY }];

// Player object (Doodle)
const doodle = {
  width: 40,
  height: 60,
  x: canvas.width / 2 - 20,
  y: initialPlatformY - 60,
  dx: 0,
  dy: 0
};

// Initialize platform spawning
let platformY = initialPlatformY;
while (platformY > 0) {
  platformY -= platformHeight + Math.random() * maxPlatformGap;
  const platformX = Math.random() * (canvas.width - platformWidth);
  platforms.push({ x: platformX, y: platformY });
}

// Game state variables
let isLeftPressed = false;
let isRightPressed = false;

// Keydown and keyup event listeners for player control
document.addEventListener('keydown', (e) => {
  if (e.key === 'ArrowLeft') {
    isLeftPressed = true;
  } else if (e.key === 'ArrowRight') {
    isRightPressed = true;
  }
});

document.addEventListener('keyup', (e) => {
  if (e.key === 'ArrowLeft') {
    isLeftPressed = false;
  } else if (e.key === 'ArrowRight') {
    isRightPressed = false;
  }
});

// Game loop function
function gameLoop() {
  context.clearRect(0, 0, canvas.width, canvas.height);
  
  // Apply gravity to the player
  doodle.dy += gravity;
  
  // Move the doodle
  doodle.x += doodle.dx;
  doodle.y += doodle.dy;
  
  // Platform collision detection
  platforms.forEach((platform) => {
    if (
      doodle.dy > 0 &&
      doodle.x + doodle.width > platform.x &&
      doodle.x < platform.x + platformWidth &&
      doodle.y + doodle.height > platform.y &&
      doodle.y + doodle.height < platform.y + platformHeight
    ) {
      doodle.dy = bounceVelocity;
    }
  });
  
  // Move platforms down when doodle jumps above half screen
  if (doodle.y < canvas.height / 2 && doodle.dy < 0) {
    platforms.forEach((platform) => {
      platform.y -= doodle.dy;
    });
    
    // Remove platforms that have gone off-screen
    platforms = platforms.filter(platform => platform.y < canvas.height);
    
    // Add new platforms to the top
    while (platforms[platforms.length - 1].y > 0) {
      const newPlatformX = Math.random() * (canvas.width - platformWidth);
      const newPlatformY = platforms[platforms.length - 1].y - platformHeight - Math.random() * maxPlatformGap;
      platforms.push({ x: newPlatformX, y: newPlatformY });
    }
  }
  
  // Player movement controls
  if (isLeftPressed) {
    doodle.dx = -horizontalSpeed;
  } else if (isRightPressed) {
    doodle.dx = horizontalSpeed;
  } else {
    doodle.dx = 0;
  }
  
  // Screen wrapping
  if (doodle.x > canvas.width) {
    doodle.x = -doodle.width;
  } else if (doodle.x + doodle.width < 0) {
    doodle.x = canvas.width;
  }
  
  // Render platforms
  context.fillStyle = 'green';
  platforms.forEach(platform => {
    context.fillRect(platform.x, platform.y, platformWidth, platformHeight);
  });
  
  // Render player (doodle)
  context.fillStyle = 'yellow';
  context.fillRect(doodle.x, doodle.y, doodle.width, doodle.height);
  
  requestAnimationFrame(gameLoop);
}

// Start the game loop
requestAnimationFrame(gameLoop);
</script>

</body>
</html>
