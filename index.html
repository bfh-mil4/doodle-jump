<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Doodle Jump - Modern Version</title>
  <style>
    html, body {
      height: 100%;
      margin: 0;
      display: flex;
      justify-content: center;
      align-items: center;
      background-color: #282c34;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    }
    canvas {
      border: 3px solid #00FF00;
      background-color: #add8e6;
      box-shadow: 0px 0px 15px 5px rgba(0, 255, 0, 0.75);
      width: 100%;
      height: auto;
      max-width: 900px;
      max-height: 1600px;
    }
    #scoreboard {
      position: absolute;
      top: 10px;
      left: 10px;
      font-size: 24px;
      color: #00FF00;
      font-weight: bold;
    }
    #restart, #startButton {
      display: none;
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 28px;
      padding: 15px 30px;
      background-color: #28a745;
      color: white;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      box-shadow: 0px 0px 10px rgba(0, 255, 0, 0.75);
    }
    #restart {
      display: none;
      top: 70%;
    }
    #instructions {
      position: absolute;
      top: 20%;
      left: 50%;
      transform: translateX(-50%);
      text-align: center;
      font-size: 22px;
      color: #FFFFFF;
    }
    #instructions h1 {
      margin-bottom: 20px;
      color: #00FF00;
      text-shadow: 0 0 10px rgba(0, 255, 0, 0.75);
    }
    #startButton {
      margin-top: 20px;
      display: block;
      position: relative;
      transform: none;
      left: 50%;
      transform: translateX(-50%);
    }
  </style>
</head>
<body>

<canvas id="gameCanvas" width="375" height="667"></canvas>
<div id="scoreboard">Score: 0 | Highscore: 0</div>
<div id="instructions">
  <h1>Willkommen zu Doodle Jump!</h1>
  <p>Steuere deinen Charakter mit den Pfeiltasten nach links und rechts.</p>
  <p>Je höher du springst, desto herausfordernder wird es.</p>
  <p>Zeige dein Können!</p>
  <button id="startButton">Spiel Starten</button>
</div>
<button id="restart">Erneut versuchen</button>

<script>
// Setup the canvas and context
const canvas = document.getElementById('gameCanvas');
const context = canvas.getContext('2d');
const scoreboard = document.getElementById('scoreboard');
const restartButton = document.getElementById('restart');
const startButton = document.getElementById('startButton');
const instructions = document.getElementById('instructions');

// Load the player character and platform images
const playerImage = new Image();
playerImage.src = 'https://i.imgur.com/IaUrttj.png';  // Neue Bild-URL für den Charakter
const platformImage = new Image();
platformImage.src = 'https://i.imgur.com/yH9Vg4k.png';  // Neue Bild-URL für die Plattform

// Variable to track if the images are loaded
let isImageLoaded = false;

// Game physics and parameters
const platformWidth = 65;
const platformHeight = 20;
const gravity = 0.3;
const bounceVelocity = -13; 
const horizontalSpeed = 2;
let maxPlatformGap = 120; 
let gameStarted = false;

// Platforms array
let platforms = [{ x: canvas.width / 2 - platformWidth / 2, y: canvas.height - platformHeight - 10 }]; // Erste Plattform 10px über dem unteren Rand

// Player object (the character)
const doodle = {
  width: 40,
  height: 40,
  x: canvas.width / 2 - 20,
  y: canvas.height - platformHeight - 60, // Spieler wird 60px über der Plattform platziert
  dx: 0,
  dy: 0,
  currentPlatformY: canvas.height - platformHeight - 60 // Die erste Plattform als Bezugspunkt für die Y-Koordinate
};

let score = 0;
let highscore = 0;
let gameOver = false;
let isLeftPressed = false;
let isRightPressed = false;
let cameraOffsetY = 0;

// Add particle system for jump effects
let particles = [];

// Keydown and keyup events for player movement
document.addEventListener('keydown', (e) => {
  gameStarted = true;  
  if (e.key === 'ArrowLeft') {
    isLeftPressed = true;
  } else if (e.key === 'ArrowRight') {
    isRightPressed = true;
  }
});

document.addEventListener('keyup', (e) => {
  if (e.key === 'ArrowLeft') {
    isLeftPressed = false;
  } else if (e.key === 'ArrowRight') {
    isRightPressed = false;
  }
});

// Function to reset the game
function resetGame() {
  score = 0;
  gameStarted = false; 
  doodle.x = canvas.width / 2 - 20;
  doodle.y = canvas.height - platformHeight - 60; // Spieler wird 60px über der Plattform platziert
  doodle.dy = 0;
  doodle.currentPlatformY = canvas.height - platformHeight - 60;
  platforms = [{ x: canvas.width / 2 - platformWidth / 2, y: canvas.height - platformHeight - 10 }]; // Plattformen richtig initialisieren
  cameraOffsetY = 0;
  
  let platformY = canvas.height - platformHeight - 10;
  while (platformY > 0) {
    platformY -= platformHeight + Math.random() * maxPlatformGap;
    const platformX = Math.random() * (canvas.width - platformWidth);
    platforms.push({ x: platformX, y: platformY });
  }
  gameOver = false;
  restartButton.style.display = 'none';
  requestAnimationFrame(gameLoop);
}

// Function to end the game
function endGame() {
  gameOver = true;
  if (score > highscore) {
    highscore = score;
  }
  scoreboard.innerText = `Score: ${score} | Highscore: ${highscore}`;
  restartButton.style.display = 'block';
}

// Function to reliably increase the score
function handleScoreIncrease(platform) {
  if (platform.y < doodle.currentPlatformY) {
    score++;
    doodle.currentPlatformY = platform.y;
    scoreboard.innerText = `Score: ${score} | Highscore: ${highscore}`;
    maxPlatformGap = Math.min(200, maxPlatformGap + 5);
  }
}

// Platform collision detection and score increase logic
function handlePlatformCollisions() {
  platforms.forEach((platform) => {
    if (
      doodle.dy > 0 &&
      doodle.x + doodle.width > platform.x &&
      doodle.x < platform.x + platformWidth &&
      doodle.y + doodle.height > platform.y &&
      doodle.y + doodle.height < platform.y + platformHeight
    ) {
      doodle.dy = bounceVelocity;
      createParticles(doodle.x + doodle.width / 2, doodle.y + doodle.height);
      handleScoreIncrease(platform);
    }
  });
}

// Game loop function
function gameLoop() {
  context.clearRect(0, 0, canvas.width, canvas.height);

  if (gameStarted) {
    doodle.dy += gravity;
  }
  
  doodle.x += doodle.dx;
  doodle.y += doodle.dy;

  if (doodle.y < canvas.height / 2) {
    const offset = canvas.height / 2 - doodle.y;
    cameraOffsetY += offset;
    doodle.y = canvas.height / 2;
    platforms.forEach(platform => platform.y += offset);
  }

  handlePlatformCollisions();

  platforms = platforms.filter(platform => platform.y < canvas.height);

  if (platforms[platforms.length - 1].y > 0) {
    const newPlatformX = Math.random() * (canvas.width - platformWidth);
    const newPlatformY = platforms[platforms.length - 1].y - platformHeight - Math.random() * maxPlatformGap;
    platforms.push({ x: newPlatformX, y: newPlatformY });
  }

  if (isLeftPressed) {
    doodle.dx = -horizontalSpeed;
  } else if (isRightPressed) {
    doodle.dx = horizontalSpeed;
  } else {
    doodle.dx = 0;
  }

  if (doodle.x + doodle.width < 0) {
    doodle.x = canvas.width;
  } else if (doodle.x > canvas.width) {
    doodle.x = -doodle.width;
  }

  platforms.forEach(platform => {
    context.drawImage(platformImage, platform.x, platform.y, platformWidth, platformHeight);
  });

  if (isImageLoaded) {
    context.drawImage(playerImage, doodle.x, doodle.y, doodle.width, doodle.height);
  }

  updateParticles();
  renderParticles();

  if (doodle.y - cameraOffsetY > canvas.height) {
    endGame();
    return;
  }

  if (!gameOver) {
    requestAnimationFrame(gameLoop);
  }
}

canvas.style.display = 'none';

</script>

</body>
</html>
